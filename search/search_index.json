{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction A typical office or enthusiast LAN will have several web services hosted privately, with private domain names resolved by a private DNS server. We'd like these services to use HTTPS, with SSL/TLS certificates which have valid chains of trust, but for privacy and cost reasons we don't want to get a real-world Certificate Authority (CA) involved in issuing our private service certificates. The solution is to create our own CA and sign our own service certificates. This entity will represent a new root point of trust which our services' clients can explicitly accept, and which can delegate its trust to our various private SSL/TLS service certificates. However, this plan has important implications for security and privacy. Trusting any CA implies that any certificate signed by that CA is also trusted. This broad trust could be exploited to issue fraudulent certificates for 3rd party domains if the agency which controls the CA chose to undermine the privacy and security of the clients who trusted it, or if the CA certificate and key were simply stolen. In order to mitigate this risk, we'd like to limit the CA such that its trust only extends to domains which match a given whitelist. Clients can then verify this condition by inspecting the CA certificate before trusting it and be assured that, at worst, their risk extends only to a limited set of domains. In addition, we'd like to find a balance between convenience and security when it comes to handling the CA's confidential files. To do so while still enabling convenient signing of new service certificates, we'll create an intermediate certificate signed by the root CA certificate, which is then used for signing the various service certificates. This structuring of the CA into a root and an intermediate certificate will allow us to avoid the need for frequent access to the root CA certificate's key. For example, the root certificate's control files can be locked away in a safe on a USB drive. This division will also give us a trusted fallback position from which to revoke the intermediate CA certificate if it were compromised. And finally, the intermediate certificate can have a relatively short expiration date, with a replacement intermediate certificate being rotated into usage near the existing one's end of life, without having to redistribute a trusted certificate for all the clients. In summary, we want: A single long-lived root CA certificate, limited to just an agreed-upon set of domains with X.509 Name Constraints , which can be trusted by our services' clients. An intermediate CA certificate, signed by the root CA certificate. Various SSL/TLS service certificates for each of our services on the private network, signed by the intermediate CA certificate. In addition, we'd like some process and tooling for securely and conveniently managing our new Certificate Authority. Specifically, we want to know how to: Generate our new CA root certificate from scratch Distribute the CA root certificate for clients to trust Generate and later re-generate our intermediate certificate Sign new service certificates and periodically replace expiring service certificates Revoke certificates that are no longer considered valid Store the root and intermediate CA certificates in a safe manner Ideally, this would be a small set of archive files we could securely store offline, and some stateless tooling scripts that can operate on those archives to perform the various certificate maintenance tasks. The rest of this guide will go into detail on how to accomplish these goals, and some advice on maintaining it all with a minimum of hassle.","title":"Introduction"},{"location":"#introduction","text":"A typical office or enthusiast LAN will have several web services hosted privately, with private domain names resolved by a private DNS server. We'd like these services to use HTTPS, with SSL/TLS certificates which have valid chains of trust, but for privacy and cost reasons we don't want to get a real-world Certificate Authority (CA) involved in issuing our private service certificates. The solution is to create our own CA and sign our own service certificates. This entity will represent a new root point of trust which our services' clients can explicitly accept, and which can delegate its trust to our various private SSL/TLS service certificates. However, this plan has important implications for security and privacy. Trusting any CA implies that any certificate signed by that CA is also trusted. This broad trust could be exploited to issue fraudulent certificates for 3rd party domains if the agency which controls the CA chose to undermine the privacy and security of the clients who trusted it, or if the CA certificate and key were simply stolen. In order to mitigate this risk, we'd like to limit the CA such that its trust only extends to domains which match a given whitelist. Clients can then verify this condition by inspecting the CA certificate before trusting it and be assured that, at worst, their risk extends only to a limited set of domains. In addition, we'd like to find a balance between convenience and security when it comes to handling the CA's confidential files. To do so while still enabling convenient signing of new service certificates, we'll create an intermediate certificate signed by the root CA certificate, which is then used for signing the various service certificates. This structuring of the CA into a root and an intermediate certificate will allow us to avoid the need for frequent access to the root CA certificate's key. For example, the root certificate's control files can be locked away in a safe on a USB drive. This division will also give us a trusted fallback position from which to revoke the intermediate CA certificate if it were compromised. And finally, the intermediate certificate can have a relatively short expiration date, with a replacement intermediate certificate being rotated into usage near the existing one's end of life, without having to redistribute a trusted certificate for all the clients. In summary, we want: A single long-lived root CA certificate, limited to just an agreed-upon set of domains with X.509 Name Constraints , which can be trusted by our services' clients. An intermediate CA certificate, signed by the root CA certificate. Various SSL/TLS service certificates for each of our services on the private network, signed by the intermediate CA certificate. In addition, we'd like some process and tooling for securely and conveniently managing our new Certificate Authority. Specifically, we want to know how to: Generate our new CA root certificate from scratch Distribute the CA root certificate for clients to trust Generate and later re-generate our intermediate certificate Sign new service certificates and periodically replace expiring service certificates Revoke certificates that are no longer considered valid Store the root and intermediate CA certificates in a safe manner Ideally, this would be a small set of archive files we could securely store offline, and some stateless tooling scripts that can operate on those archives to perform the various certificate maintenance tasks. The rest of this guide will go into detail on how to accomplish these goals, and some advice on maintaining it all with a minimum of hassle.","title":"Introduction"},{"location":"details_and_setup/","text":"Operational Overview The OpenSSL command line tool is the intimidating Swiss Army knife that performs practically all of the functions necessary for running a CA. We'll only use a fraction of its features for this project. In addition to generating keys and certificates and handling signing requests, OpenSSL can maintain a database of all the issued certificates signed by the CA. Also, an incrementing serial number for issued certs can be kept to aid in auditing. The database of issued certs and the serial number state are stored in text files alongside the certificates they describe, and these files will need to be preserved together with the CA certificates. To do so, we'll generate one archive of the entire CA working set ( ca_authority.tar.gz ), and another for just the subset of files defining the intermediate certificate ( intermediate_authority.tar.gz ). These archives can then be stored in separate safe locations between uses, allowing the less-risky intermediate authority certificate to be used to sign service certificates, without having to risk frequent access to the more dangerous root certificate. Setting Up a Docker Working Environment In order to provide a self-contained repeatable infrastructure for operating the CA, we'll use Docker containers with the necessary tools pre-installed. These short-lived containers can be destroyed and regenerated between CA duties, as long as we're careful to archive the work done at the end of each session . We'll cover the details of doing so later in this guide. Setting up a Docker host environment on your computer is beyond the scope of this document, but it's not especially difficult. A good place to start is the Docker Community Edition website . Once you've got Docker installed, clone this site's code repository to a working directory: git clone https://github.com/triplepoint/certificate-authority-guide cd certificate-authority-guide/src Then with the provided helper script, build the Dockerfile into a Docker image and launch a Docker instance from that image: ./scripts/run If you inspect the above run script, in the docker run command, the --mount parameter is defining a local source directory ( ./archives ) to mount as /root/ca_persist inside the Docker container. This directory, shared between the host machine and the Docker container, is how we'll preserve the CA archives after we terminate the container. When the above command is run, you'll have a Bash shell into that new container, in the container's /root/ca directory. This is the working directory in which all the CA management work will take place. The idea is that whatever work happens in here can be archived and moved (within the container) to /root/ca_persist , which will preserve it on the host machine after the container is terminated. If the shared mount directory already has the ca_authority.tar.gz and/or intermediate_authority.tar.gz files present when the container is created, then these pre-existing archives will be unpacked into the /root/ca working directory on the Docker container when the container is created. If both these archives are missing, then a new skeleton directory structure will be prepared. Note that the root CA authority archive also contains the contents of the intermediate CA authority archive, and if both archive files are present in the shared mount, the root CA authority will take precedence. See the Docker image's entrypoint.sh file for more details about what happens when the Docker container is created. Remember, it's your responsibility to ensure that new work done inside the Docker container is archived before the container is exited and destroyed. We'll explain more about how to do this later in this guide. Note that in the run script above, we're creating a local ./archives directory to use as the source archive directory on the host. You could instead provide the path to a mounted USB drive and avoid copying the archives onto your computer. Be aware that Docker requires that path to be an absolute path. Be sure not to omit the --rm flag; this container will generate confidential files, and we want to destroy it once we're done working inside the container and have safely re-created the archives. Verifying the Environment Before we move on to setting up our Certificate Authority, go ahead and run the commands above and ensure that you've got a command prompt inside the Docker container. You can verify things are set up properly by running the pwd and tree commands to see which directory you're in, and whether the skeleton root CA authority is set up: root@b802e56f10b6:~/ca# pwd /root/ca root@b802e56f10b6:~/ca# tree . |-- ca_openssl.cnf |-- certs |-- crl |-- crlnumber |-- csr |-- index.txt |-- intermediate | |-- ca_openssl.cnf | |-- certs | |-- crl | |-- crlnumber | |-- csr | |-- index.txt | |-- newcerts | |-- private | `-- serial |-- newcerts |-- private `-- serial 11 directories, 8 files Unless specified otherwise, the commands in the rest of this guide are executed inside the context of this Docker image. At any point you can run exit to leave the docker container and destroy it.","title":"Operational Overview and Setup"},{"location":"details_and_setup/#operational-overview","text":"The OpenSSL command line tool is the intimidating Swiss Army knife that performs practically all of the functions necessary for running a CA. We'll only use a fraction of its features for this project. In addition to generating keys and certificates and handling signing requests, OpenSSL can maintain a database of all the issued certificates signed by the CA. Also, an incrementing serial number for issued certs can be kept to aid in auditing. The database of issued certs and the serial number state are stored in text files alongside the certificates they describe, and these files will need to be preserved together with the CA certificates. To do so, we'll generate one archive of the entire CA working set ( ca_authority.tar.gz ), and another for just the subset of files defining the intermediate certificate ( intermediate_authority.tar.gz ). These archives can then be stored in separate safe locations between uses, allowing the less-risky intermediate authority certificate to be used to sign service certificates, without having to risk frequent access to the more dangerous root certificate.","title":"Operational Overview"},{"location":"details_and_setup/#setting-up-a-docker-working-environment","text":"In order to provide a self-contained repeatable infrastructure for operating the CA, we'll use Docker containers with the necessary tools pre-installed. These short-lived containers can be destroyed and regenerated between CA duties, as long as we're careful to archive the work done at the end of each session . We'll cover the details of doing so later in this guide. Setting up a Docker host environment on your computer is beyond the scope of this document, but it's not especially difficult. A good place to start is the Docker Community Edition website . Once you've got Docker installed, clone this site's code repository to a working directory: git clone https://github.com/triplepoint/certificate-authority-guide cd certificate-authority-guide/src Then with the provided helper script, build the Dockerfile into a Docker image and launch a Docker instance from that image: ./scripts/run If you inspect the above run script, in the docker run command, the --mount parameter is defining a local source directory ( ./archives ) to mount as /root/ca_persist inside the Docker container. This directory, shared between the host machine and the Docker container, is how we'll preserve the CA archives after we terminate the container. When the above command is run, you'll have a Bash shell into that new container, in the container's /root/ca directory. This is the working directory in which all the CA management work will take place. The idea is that whatever work happens in here can be archived and moved (within the container) to /root/ca_persist , which will preserve it on the host machine after the container is terminated. If the shared mount directory already has the ca_authority.tar.gz and/or intermediate_authority.tar.gz files present when the container is created, then these pre-existing archives will be unpacked into the /root/ca working directory on the Docker container when the container is created. If both these archives are missing, then a new skeleton directory structure will be prepared. Note that the root CA authority archive also contains the contents of the intermediate CA authority archive, and if both archive files are present in the shared mount, the root CA authority will take precedence. See the Docker image's entrypoint.sh file for more details about what happens when the Docker container is created. Remember, it's your responsibility to ensure that new work done inside the Docker container is archived before the container is exited and destroyed. We'll explain more about how to do this later in this guide. Note that in the run script above, we're creating a local ./archives directory to use as the source archive directory on the host. You could instead provide the path to a mounted USB drive and avoid copying the archives onto your computer. Be aware that Docker requires that path to be an absolute path. Be sure not to omit the --rm flag; this container will generate confidential files, and we want to destroy it once we're done working inside the container and have safely re-created the archives.","title":"Setting Up a Docker Working Environment"},{"location":"details_and_setup/#verifying-the-environment","text":"Before we move on to setting up our Certificate Authority, go ahead and run the commands above and ensure that you've got a command prompt inside the Docker container. You can verify things are set up properly by running the pwd and tree commands to see which directory you're in, and whether the skeleton root CA authority is set up: root@b802e56f10b6:~/ca# pwd /root/ca root@b802e56f10b6:~/ca# tree . |-- ca_openssl.cnf |-- certs |-- crl |-- crlnumber |-- csr |-- index.txt |-- intermediate | |-- ca_openssl.cnf | |-- certs | |-- crl | |-- crlnumber | |-- csr | |-- index.txt | |-- newcerts | |-- private | `-- serial |-- newcerts |-- private `-- serial 11 directories, 8 files Unless specified otherwise, the commands in the rest of this guide are executed inside the context of this Docker image. At any point you can run exit to leave the docker container and destroy it.","title":"Verifying the Environment"},{"location":"distribution/","text":"Distributing the CA Certificate to Clients TODO - cover: what we're doing here, by distributing the root certificate to clients and trusting it What file(s) need to be distributed what channel can these certificates be transferred by how do you trust a certificate on a client: macos linux windows note about specific applications","title":"Root Certificate Distribution"},{"location":"distribution/#distributing-the-ca-certificate-to-clients","text":"TODO - cover: what we're doing here, by distributing the root certificate to clients and trusting it What file(s) need to be distributed what channel can these certificates be transferred by how do you trust a certificate on a client: macos linux windows note about specific applications","title":"Distributing the CA Certificate to Clients"},{"location":"generating_ca/","text":"Building a Certificate Authority A Note on the OpenSSL Config Files In our skeleton CA file structure, we've provided a copy of the openssl config file in both the /root/ca and /root/ca/intermediate directory. These files are identical, but they're duplicated to ensure that the intermediate CA archive has its own copy if it's ever used on its own (for example, when signing a service certificate). If for any reason you modify one of these files, be sure to similarly modify the other one. We'll be careful below to explicitly set the openssl -config and -name flags for each scenario, but just be aware these two files are (or at least should be) identical. Generating a Root CA Certificate The Certificate Authority's core documents are its root certificate and the associated private key. This is the certificate which all clients will directly trust, and it's the root of the chain of trust that ultimately extends down to the individual service certificates. You'll (hopefully) only need to generate this root certificate and its key once. We'll set the expiration for ~25 years (9130 days), and as long as the certificate isn't compromised and you don't make any mistakes, you can rely on it to function for that long. Generate a new Key for the CA Root Certificate First, we need to generate a new RSA key for the CA certificate. The key will be encrypted with a passphrase, which you'll be prompted to supply. You'll want to use a real non-empty password for this key and store it in a safe place. openssl genrsa \\ -aes256 \\ -out /root/ca/private/ca.key.pem \\ 4096 && \\ chmod 400 /root/ca/private/ca.key.pem This generates the new CA key at /root/ca/private/ca.key.pem . Generate a Certificate Signing Request for the CA Root Certificate Next, we need to generate a Certificate Signing Request (CSR) which will define the details of the CA certificate, and which will be used to self-sign the new certificate. When you are prompted for the CA Certificate Distinguished Name details, take care to get them right. You won't want to regenerate the certificate after it's been distributed. openssl req \\ -config /root/ca/ca_openssl.cnf \\ -key /root/ca/private/ca.key.pem \\ -new \\ -sha256 \\ -out /root/ca/ca.req.pem This generates the new CSR for the root certificate at /root/ca/ca.req.pem . Self-Sign the Root Certificate Now that we have the key and a signing request, we can act on the request to self-sign the root certificate: openssl ca \\ -config /root/ca/ca_openssl.cnf \\ -name CA_root \\ -in /root/ca/ca.req.pem \\ -create_serial \\ -out /root/ca/certs/ca.cert.pem \\ -days 9130 \\ -keyfile /root/ca/private/ca.key.pem \\ -selfsign \\ -extensions v3_ca This generates the new CA root certificate at /root/ca/certs/ca.cert.pem . When you are prompted about \"committing\" say y ; this is about starting a database of certificates signed by this authority. Verifying the Root Certificate Now that the root CA certificate and key are generated, you can verify them with: openssl x509 -noout -text -in /root/ca/certs/ca.cert.pem TODO - what are we looking at? Generating an Intermediate CA Certificate Generate a New Key for the Intermediate Certificate Similar to what we did for the CA root certificate above, we need to generate a signing key for the CA intermediate certificate. Once again, you'll need to use a non-empty secure password and store it in a secure place: openssl genrsa \\ -aes256 \\ -out /root/ca/intermediate/private/intermediate.key.pem \\ 4096 && \\ chmod 400 /root/ca/intermediate/private/intermediate.key.pem This generates the new intermediate certificate key at: /root/ca/intermediate/private/intermediate.key.pem . Generate a Certificate Signing Request for the Intermediate Certificate This document represents a request to the root CA to generate the signed intermediate certificate. Note that the Country Name , State or Province Name , and Organization Name all have to match the values of the root CA certificate. Also note that the Common Name used in this CSR must be distinct from the root CA certificate's Common Name, used above. openssl req \\ -config /root/ca/intermediate/int_openssl.cnf \\ -key /root/ca/intermediate/private/intermediate.key.pem \\ -new \\ -sha256 \\ -out /root/ca/intermediate/csr/intermediate.csr.pem Sign the Intermediate Certificate with the CA Certificate Now we can sign the intermediate certificate with the root certificate and the root certificate's key: openssl ca \\ -config /root/ca/ca_openssl.cnf \\ -in /root/ca/intermediate/csr/intermediate.csr.pem \\ -notext \\ -out /root/ca/intermediate/certs/intermediate.cert.pem \\ -days 3650 \\ -md sha256 \\ -extensions v3_intermediate_ca && \\ chmod 444 /root/ca/intermediate/certs/intermediate.cert.pem Answer y to any prompts about \"commiting\", this is about the database of signed certificates that OpenSSL is keeping for us (see below). This generates the new Intermediate certificate at: /root/ca/intermediate/certs/intermediate.cert.pem . Note here that we're giving the intermediate certificate a 10 year (3650 day) lifetime. Verifying the Intermediate Certificate Once generated, you can verify the certificate's values with: openssl x509 \\ -noout \\ -text \\ -in /root/ca/intermediate/certs/intermediate.cert.pem And you can verify the intermediate certificate's chain of trust against the CA certificate is valid with: openssl verify \\ -CAfile /root/ca/certs/ca.cert.pem \\ /root/ca/intermediate/certs/intermediate.cert.pem Creating a Chain File It's often convenient to have a combined \"chain file\" for a given service certificate, to represent in one place the complete chain of trust back to a trusted root certificate. Many SSL/TLS configurations expect to have these files. These chain files are simply the concatenated set of all the certificates in the chain of trust which lead back to the trusted CA root certificate: cat /root/ca/intermediate/certs/intermediate.cert.pem \\ /root/ca/certs/ca.cert.pem > \\ /root/ca/intermediate/certs/ca-chain.cert.pem && \\ chmod 444 /root/ca/intermediate/certs/ca-chain.cert.pem These are all of the CA's public certificates, so it's safe to distribute this /root/ca/intermediate/certs/ca-chain.cert.pem file to the services with the service certificates. Safe Storage The above work has generated several files which so far only exist on this Docker container, and which now need to be preserved: The CA root certificate and its associated key file The CA intermediate certificate and its associated key file The chain file combining both certificates A set of index.txt* and serial* files, one for each of the two CA certificates, which track what certificates have been signed with which CA certificates The *openssl.cnf files, one for each CA certificate, which configured OpenSSL during the various operations While not all of these files are confidential information, they should all nonetheless be packaged together and prepared for storage. This ensures that over the years, you can reliably rebuild this working environment to perform certificate-related tasks. We'll package the entire working set up into one archive at /root/ca_authority.tar.gz . This file contains everything needed to operate the CA, and therefore should be stored in a seldom-accessed, higher-security location. We'll also package just the intermediate authority's files into a separate archive at /root/intermediate_authority.tar.gz . Of the two archives, this is the file we'll use the most, since it's all that's necessary for managing service SSL/TLS certificates. It can be stored in the more-convenient, less-secure site. Remember to store both keys' passwords somewhere safe as well. We can create the archives like this: tar -czvf /root/ca_authority.tar.gz -C /root/ca/ . cp /root/ca_authority.tar.gz /root/ca_persist tar -czvf /root/intermediate_authority.tar.gz -C /root/ca/intermediate/ . cp /root/intermediate_authority.tar.gz /root/ca_persist Because this \"export\" behavior is critical, the above shell commands are also provided on the Docker image as a script named archive_ca . You can call this command at any time to archive the working set back to the persistent directory on the Docker host: archive_ca As a final note: as the intermediate archive is used, it will accrue records in its signed-certificates database and Certificate Revocation List which aren't present in the root authority archive. Periodically, the intermediate/ directory in the root CA archive will need to be replaced with the one in the intermediate_authority archive. As the two archives are overlaid when both are present during unarchival, this can be accomplished by having both archives present, creating the container, and then running archive_ca .","title":"Generating a Certificate Authority"},{"location":"generating_ca/#building-a-certificate-authority","text":"","title":"Building a Certificate Authority"},{"location":"generating_ca/#a-note-on-the-openssl-config-files","text":"In our skeleton CA file structure, we've provided a copy of the openssl config file in both the /root/ca and /root/ca/intermediate directory. These files are identical, but they're duplicated to ensure that the intermediate CA archive has its own copy if it's ever used on its own (for example, when signing a service certificate). If for any reason you modify one of these files, be sure to similarly modify the other one. We'll be careful below to explicitly set the openssl -config and -name flags for each scenario, but just be aware these two files are (or at least should be) identical.","title":"A Note on the OpenSSL Config Files"},{"location":"generating_ca/#generating-a-root-ca-certificate","text":"The Certificate Authority's core documents are its root certificate and the associated private key. This is the certificate which all clients will directly trust, and it's the root of the chain of trust that ultimately extends down to the individual service certificates. You'll (hopefully) only need to generate this root certificate and its key once. We'll set the expiration for ~25 years (9130 days), and as long as the certificate isn't compromised and you don't make any mistakes, you can rely on it to function for that long.","title":"Generating a Root CA Certificate"},{"location":"generating_ca/#generate-a-new-key-for-the-ca-root-certificate","text":"First, we need to generate a new RSA key for the CA certificate. The key will be encrypted with a passphrase, which you'll be prompted to supply. You'll want to use a real non-empty password for this key and store it in a safe place. openssl genrsa \\ -aes256 \\ -out /root/ca/private/ca.key.pem \\ 4096 && \\ chmod 400 /root/ca/private/ca.key.pem This generates the new CA key at /root/ca/private/ca.key.pem .","title":"Generate a new Key for the CA Root Certificate"},{"location":"generating_ca/#generate-a-certificate-signing-request-for-the-ca-root-certificate","text":"Next, we need to generate a Certificate Signing Request (CSR) which will define the details of the CA certificate, and which will be used to self-sign the new certificate. When you are prompted for the CA Certificate Distinguished Name details, take care to get them right. You won't want to regenerate the certificate after it's been distributed. openssl req \\ -config /root/ca/ca_openssl.cnf \\ -key /root/ca/private/ca.key.pem \\ -new \\ -sha256 \\ -out /root/ca/ca.req.pem This generates the new CSR for the root certificate at /root/ca/ca.req.pem .","title":"Generate a Certificate Signing Request for the CA Root Certificate"},{"location":"generating_ca/#self-sign-the-root-certificate","text":"Now that we have the key and a signing request, we can act on the request to self-sign the root certificate: openssl ca \\ -config /root/ca/ca_openssl.cnf \\ -name CA_root \\ -in /root/ca/ca.req.pem \\ -create_serial \\ -out /root/ca/certs/ca.cert.pem \\ -days 9130 \\ -keyfile /root/ca/private/ca.key.pem \\ -selfsign \\ -extensions v3_ca This generates the new CA root certificate at /root/ca/certs/ca.cert.pem . When you are prompted about \"committing\" say y ; this is about starting a database of certificates signed by this authority.","title":"Self-Sign the Root Certificate"},{"location":"generating_ca/#verifying-the-root-certificate","text":"Now that the root CA certificate and key are generated, you can verify them with: openssl x509 -noout -text -in /root/ca/certs/ca.cert.pem TODO - what are we looking at?","title":"Verifying the Root Certificate"},{"location":"generating_ca/#generating-an-intermediate-ca-certificate","text":"","title":"Generating an Intermediate CA Certificate"},{"location":"generating_ca/#generate-a-new-key-for-the-intermediate-certificate","text":"Similar to what we did for the CA root certificate above, we need to generate a signing key for the CA intermediate certificate. Once again, you'll need to use a non-empty secure password and store it in a secure place: openssl genrsa \\ -aes256 \\ -out /root/ca/intermediate/private/intermediate.key.pem \\ 4096 && \\ chmod 400 /root/ca/intermediate/private/intermediate.key.pem This generates the new intermediate certificate key at: /root/ca/intermediate/private/intermediate.key.pem .","title":"Generate a New Key for the Intermediate Certificate"},{"location":"generating_ca/#generate-a-certificate-signing-request-for-the-intermediate-certificate","text":"This document represents a request to the root CA to generate the signed intermediate certificate. Note that the Country Name , State or Province Name , and Organization Name all have to match the values of the root CA certificate. Also note that the Common Name used in this CSR must be distinct from the root CA certificate's Common Name, used above. openssl req \\ -config /root/ca/intermediate/int_openssl.cnf \\ -key /root/ca/intermediate/private/intermediate.key.pem \\ -new \\ -sha256 \\ -out /root/ca/intermediate/csr/intermediate.csr.pem","title":"Generate a Certificate Signing Request for the Intermediate Certificate"},{"location":"generating_ca/#sign-the-intermediate-certificate-with-the-ca-certificate","text":"Now we can sign the intermediate certificate with the root certificate and the root certificate's key: openssl ca \\ -config /root/ca/ca_openssl.cnf \\ -in /root/ca/intermediate/csr/intermediate.csr.pem \\ -notext \\ -out /root/ca/intermediate/certs/intermediate.cert.pem \\ -days 3650 \\ -md sha256 \\ -extensions v3_intermediate_ca && \\ chmod 444 /root/ca/intermediate/certs/intermediate.cert.pem Answer y to any prompts about \"commiting\", this is about the database of signed certificates that OpenSSL is keeping for us (see below). This generates the new Intermediate certificate at: /root/ca/intermediate/certs/intermediate.cert.pem . Note here that we're giving the intermediate certificate a 10 year (3650 day) lifetime.","title":"Sign the Intermediate Certificate with the CA Certificate"},{"location":"generating_ca/#verifying-the-intermediate-certificate","text":"Once generated, you can verify the certificate's values with: openssl x509 \\ -noout \\ -text \\ -in /root/ca/intermediate/certs/intermediate.cert.pem And you can verify the intermediate certificate's chain of trust against the CA certificate is valid with: openssl verify \\ -CAfile /root/ca/certs/ca.cert.pem \\ /root/ca/intermediate/certs/intermediate.cert.pem","title":"Verifying the Intermediate Certificate"},{"location":"generating_ca/#creating-a-chain-file","text":"It's often convenient to have a combined \"chain file\" for a given service certificate, to represent in one place the complete chain of trust back to a trusted root certificate. Many SSL/TLS configurations expect to have these files. These chain files are simply the concatenated set of all the certificates in the chain of trust which lead back to the trusted CA root certificate: cat /root/ca/intermediate/certs/intermediate.cert.pem \\ /root/ca/certs/ca.cert.pem > \\ /root/ca/intermediate/certs/ca-chain.cert.pem && \\ chmod 444 /root/ca/intermediate/certs/ca-chain.cert.pem These are all of the CA's public certificates, so it's safe to distribute this /root/ca/intermediate/certs/ca-chain.cert.pem file to the services with the service certificates.","title":"Creating a Chain File"},{"location":"generating_ca/#safe-storage","text":"The above work has generated several files which so far only exist on this Docker container, and which now need to be preserved: The CA root certificate and its associated key file The CA intermediate certificate and its associated key file The chain file combining both certificates A set of index.txt* and serial* files, one for each of the two CA certificates, which track what certificates have been signed with which CA certificates The *openssl.cnf files, one for each CA certificate, which configured OpenSSL during the various operations While not all of these files are confidential information, they should all nonetheless be packaged together and prepared for storage. This ensures that over the years, you can reliably rebuild this working environment to perform certificate-related tasks. We'll package the entire working set up into one archive at /root/ca_authority.tar.gz . This file contains everything needed to operate the CA, and therefore should be stored in a seldom-accessed, higher-security location. We'll also package just the intermediate authority's files into a separate archive at /root/intermediate_authority.tar.gz . Of the two archives, this is the file we'll use the most, since it's all that's necessary for managing service SSL/TLS certificates. It can be stored in the more-convenient, less-secure site. Remember to store both keys' passwords somewhere safe as well. We can create the archives like this: tar -czvf /root/ca_authority.tar.gz -C /root/ca/ . cp /root/ca_authority.tar.gz /root/ca_persist tar -czvf /root/intermediate_authority.tar.gz -C /root/ca/intermediate/ . cp /root/intermediate_authority.tar.gz /root/ca_persist Because this \"export\" behavior is critical, the above shell commands are also provided on the Docker image as a script named archive_ca . You can call this command at any time to archive the working set back to the persistent directory on the Docker host: archive_ca As a final note: as the intermediate archive is used, it will accrue records in its signed-certificates database and Certificate Revocation List which aren't present in the root authority archive. Periodically, the intermediate/ directory in the root CA archive will need to be replaced with the one in the intermediate_authority archive. As the two archives are overlaid when both are present during unarchival, this can be accomplished by having both archives present, creating the container, and then running archive_ca .","title":"Safe Storage"},{"location":"references/","text":"References Jamie Nguyen -- OpenSSL Certificate Authority Robert Marcano -- Restrict Certificate Authority to a Domain Phil Dibowitz -- Creating a CA Fabian Lee -- Ubuntu: Creating a trusted CA and SAN certificate using OpenSSL OpenSSL documentation -- Certificate Authorities OpenSSL documentation -- Certificate Requests","title":"References"},{"location":"references/#references","text":"Jamie Nguyen -- OpenSSL Certificate Authority Robert Marcano -- Restrict Certificate Authority to a Domain Phil Dibowitz -- Creating a CA Fabian Lee -- Ubuntu: Creating a trusted CA and SAN certificate using OpenSSL OpenSSL documentation -- Certificate Authorities OpenSSL documentation -- Certificate Requests","title":"References"},{"location":"revocation_certificates/","text":"Revoking a SSL/TLS Service Certificate TODO - cover: Revoking Service Certificates What does it mean to revoke a service certificate Why would you want to revoke a service certificate? What's the basic concept of how this works? How do you actually do it? Revoking the Intermediate CA Certificate What about revoking the intermediate certificate? Note that you'd also be revoking all the certificates that it signed Get the list of all the certificates that were signed by the intermediate certificate","title":"Revoking Certificates"},{"location":"revocation_certificates/#revoking-a-ssltls-service-certificate","text":"TODO - cover:","title":"Revoking a SSL/TLS Service Certificate"},{"location":"revocation_certificates/#revoking-service-certificates","text":"What does it mean to revoke a service certificate Why would you want to revoke a service certificate? What's the basic concept of how this works? How do you actually do it?","title":"Revoking Service Certificates"},{"location":"revocation_certificates/#revoking-the-intermediate-ca-certificate","text":"What about revoking the intermediate certificate? Note that you'd also be revoking all the certificates that it signed Get the list of all the certificates that were signed by the intermediate certificate","title":"Revoking the Intermediate CA Certificate"},{"location":"service_certificates/","text":"Generating a Signed SSL/TLS Service Certificate The instructions introduced so far for generating the root CA certificate and the intermediate certificate were complex, but since they are seldom performed that should be acceptable. In contrast, the procedure for requesting a new service certificate from your CA could happen frequently. We'll need to provide some automation in order to avoid mistakes and reduce labor. We'll go through this process once manually, for explanation's sake, and then we'll introduce a script that does the same thing, but quicker and easier. TODO - SANs","title":"Service Certificates"},{"location":"service_certificates/#generating-a-signed-ssltls-service-certificate","text":"The instructions introduced so far for generating the root CA certificate and the intermediate certificate were complex, but since they are seldom performed that should be acceptable. In contrast, the procedure for requesting a new service certificate from your CA could happen frequently. We'll need to provide some automation in order to avoid mistakes and reduce labor. We'll go through this process once manually, for explanation's sake, and then we'll introduce a script that does the same thing, but quicker and easier. TODO - SANs","title":"Generating a Signed SSL/TLS Service Certificate"}]}